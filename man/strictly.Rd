% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/strictly.R
\name{strictly}
\alias{strictly}
\alias{nonstrictly}
\alias{is_strict_closure}
\title{Apply a function strictly}
\arguments{
\item{.f}{Interpreted function, i.e., a function of type \code{"closure"}.}

\item{\dots}{Check formula(e); see the section \dQuote{Check formulae}.}

\item{.checklist}{List of check formulae. These are combined with check
formulae provided via the \dots argument.}

\item{.warn_missing}{\code{TRUE} or \code{FALSE}: Should the absence of
required arguments be checked? (A \dQuote{required argument} is a (named)
argument without default value.) This question is disregarded if
\code{.warn_missing} is \code{NULL}.}

\item{.quiet}{\code{TRUE} or \code{FALSE}: Should a warning be signaled if
\code{.f} is not a function created by \code{strictly()}?}

\item{x}{Object to probe.}
}
\value{
\subsection{\code{strictly()}}{
  If neither the check formulae nor the switch \code{.warn_missing} are
  applicable to \code{.f}, then \code{strictly()} simply returns \code{.f}.
  This is the case when \code{.f} has no named arguments, i.e., \code{.f} has
  argument signature \code{function()} or \code{function(...)}.

  Otherwise, \code{strictly()} returns a function that behaves
  \emph{identically} to \code{.f}, with the exception that it validates its
  inputs, as follows:
  \enumerate{
    \item Validation: Before \code{.f} is called, every check-formula
    predicate is evaluated: for each named argument, in the case of a global
    check formula, and for each check-item expression, in the case of a local
    check formula. Every resulting value of \code{FALSE}, or failure to
    evalute the predicate itself, is tabulated as a \emph{validation error}.

    \item Error reporting: For each validation error, an error is signaled.
    Execution halts.

    \item Checks passed: If there are no validation errors, \code{.f} is
    called on the supplied arguments.
  }
  \code{strictly()} preserves the argument signature of \code{.f}, along with
  its attributes (with the execption that the resulting class is
  \code{"strict_closure"}, which inherits from the class of \code{.f}).
  }

\subsection{\code{nonstrictly()}}{
  Returns the original function without checks. (This works even if the
  original function has been removed.)}
}
\description{
\code{strictly()} transforms a function into a function with input validation
checks. \code{nonstrictly()} undoes the application of \code{strictly()}, by
returning the original function, without checks. \code{is_strict_closure()}
is a predicate function that checks whether an object is a strictly applied
function, i.e., a function created by \code{strictly()}.
}
\details{
To get started with \code{strictly()}, skip to the examples, below.
  What follows is a precise description of how to specify checks. An
  awareness of the distinction between a check formula of \dQuote{global
  scope} vs. one of \dQuote{local scope} is helpful in understanding the
  purpose and use of convenience functions, such as \code{\link{localize}()}.

  \subsection{Check formulae}{
  An input validation check is specified by a \link[stats]{formula} of the
  form
  \preformatted{
  <scope> ~ <predicate>}
  where the right-hand side expresses \emph{what} to check, and the left-hand
  side expresses \emph{where} to check it.

  The right-hand side \code{<predicate>} is a predicate function, i.e, a
  one-variable function that returns either \code{TRUE} or \code{FALSE}. The
  left-hand side \code{<scope>} is an expression specifying whether the scope
  of \code{<predicate>} is \emph{global}—applies to all (named) arguments of
  \code{.f}—or \emph{local}—applies to certain arguments or expressions
  thereof. In other words, there are two kinds of \code{<scope>}, and
  therefore two kinds of check formulae:
  \itemize{
    \item \strong{Check formulae of global scope}:\cr
    \code{~ <predicate>} (onsided) or \code{<string> ~ <predicate>}

    \item \strong{Check formulae of local scope}:\cr
    \code{list(<check_item>, <check_item>, ...) ~ <predicate>}
  }
  \subsection{Check formulae of global scope}{
    A \strong{global check formula} imposes the condition that the
    \code{<predicate>} (function) is \code{TRUE} for each (named) argument of
    \code{.f}. Each argument for which the \code{<predicate>} fails (i.e.,
    evaluates to \code{FALSE}) produces an error message, which is
    auto-generated unless a custom error message is supplied by specifying
    the string \code{<string>}.
    \cr\cr
    \emph{Example} — The assertion that all (named) arguments of a function
    must be numerical can be enforced by the check formula
    \preformatted{
    ~ is.numeric}
   or
    \preformatted{
   "Not numeric" ~ is.numeric}
   if the custom error message \code{"Not numeric"} is to be used (in lieu of
   an auto-generated error message).}

  \subsection{Check formulae of local scope}{
    A \strong{local check formula} imposes argument-specific conditions. Each
    \dQuote{check item} \code{<check_item>} is a formula of the form \code{~
    <expression>} (one-sided) or \code{<string> ~ <expression>}; it imposes
    the condition that the \code{<predicate>} (function) is \code{TRUE} for
    the expression \code{<expression>}. As for global check formulae, each
    check item for which the \code{<predicate>} fails produces an error
    message, which is auto-generated unless a custom error message is
    supplied by a string as part of the left-hand side of the check item
    (formula).
    \cr\cr
    \emph{Example} — The assertion that \code{x} and \code{y} must differ for
    the function \code{function(x, y) \{1 / (x - y)\}} can be enforced by the
    local check formulae
    \preformatted{
    list(~ x - y) ~ function(.) abs(.) > 0}
    or
    \preformatted{
    list("x, y must differ" ~ x - y) ~ function(.) abs(.) > 0}
    if the custom error message \code{"x, y must differ"} is to be used (in
    lieu of an auto-generated error message).}
  }

  \subsection{Anonymous predicate functions}{
    Following the \pkg{magrittr} package, an anonymous (predicate) function
    of a single argument \code{.} can be expressed succinctly by enclosing
    the body of such a function by curly braces \code{\{ \ldots \}}.
    \cr\cr
    \emph{Example} — The (onsided, global) check formula
    \preformatted{
    ~ {. > 0}}
    is equivalent to the check formula \code{~ function(.) {. > 0}}.
  }
}
\examples{
\dontrun{

secant <- function(f, x, dx) (f(x + dx) - f(x)) / dx

# Ensure that `f` is a function
secant_stc <- strictly(secant, list("`f` not a function" ~ f) ~ is.function)
secant_stc(log, 1, .1)    # 0.9531018
secant_stc("log", 1, .1)  # Error: "`f` not a function"

# Ensure that `x` and `dx` are numerical (possibly non-scalars)
secant_vec <- strictly(secant_stc, list(~x, ~dx) ~ is.numeric)
secant_vec(log, c(1, 2), .1)  # 0.9531018 0.4879016
secant_vec("log", 1, .1)      # Error: "`f` not a function" (as before)
secant_vec(log, "1", .1)      # Error: "FALSE: is.numeric(x)"
secant_vec("log", "1", .1)    # Two errors

# Ensure that `dx` is a numerical scalar
secant_scalar <- strictly(secant_stc, list(~dx) ~ purrr::is_scalar_numeric)
secant_scalar(log, c(1, 2), .1)    # 0.9531018 0.4879016 (as before)
secant_scalar(log, 1, c(.1, .05))  # Error: "FALSE: purrr::is_scalar_numeric(dx)"
secant_scalar(log, 1, ".1" / 2)    # Error evaluating check

# Use purrr::lift() for predicate functions with multi-argument dependencies
f <- function(f, l, r) secant(f, l, dx = r - l)
is_monotone <- function(x, y) y - x > 0
secant_right <- strictly(f, list(~list(l, r)) ~ purrr::lift(is_monotone))
secant_right(log, 1, 1.1)  # 0.9531018
secant_right(log, 1, .9)   # Error: "FALSE: purrr::lift(is_monotone)(list(l, r))"

# Alternatively, secant_right() can be implemented with a unary check
secant_right2 <- strictly(f, list(~ r - l) ~ {. > 0})
all.equal(secant_right(log, 1, 1.1), secant_right2(log, 1, 1.1))  # TRUE
secant_right2(log, 1, .9)  # Error (as before)

# strictly() won't force any argument not involved in a check
g <- strictly(function(x, y) "Pass", list(~x) ~ is.character)
g(c("a", "b"), stop("Not signaled"))  # "Pass"

# nonstrictly() recovers the underlying function
identical(nonstrictly(secant_vec), secant)  # TRUE
}

}
\seealso{
\link{components}
}
\usage{
strictly(.f, ..., .checklist = list(), .warn_missing = NULL)

nonstrictly(.f, .quiet = FALSE)

is_strict_closure(x)
}
